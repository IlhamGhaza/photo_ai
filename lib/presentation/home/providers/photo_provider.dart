import 'dart:developer';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:uuid/uuid.dart';
import '../../../core/services/auth_service.dart';
import '../../../data/models/generated_image.dart';
import '../../../data/repositories/firestore_repository.dart';
import '../../../data/repositories/storage_repository.dart';
import '../../../data/repositories/functions_repository.dart';

enum AppState { empty, uploaded, generating, error, results }

class PhotoProvider extends ChangeNotifier {
  final AuthService _authService = AuthService();
  final FirestoreRepository _firestoreRepository = FirestoreRepository();
  final StorageRepository _storageRepository = StorageRepository();
  final FunctionsRepository _functionsRepository = FunctionsRepository();
  final Uuid _uuid = const Uuid();

  AppState _appState = AppState.empty;
  File? _uploadedImageFile;
  String? _uploadedImagePath;
  String? _currentImageId;
  String? _originalImageUrl;
  List<GeneratedImage> _generatedImages = [];
  List<GeneratedImage> _savedImages = [];
  String _errorMessage = '';
  double _generationProgress = 0.0;

  // Getters
  AppState get appState => _appState;
  File? get uploadedImageFile => _uploadedImageFile;
  String? get uploadedImagePath => _uploadedImagePath;
  List<GeneratedImage> get generatedImages => _generatedImages;
  List<GeneratedImage> get savedImages => _savedImages;
  String get errorMessage => _errorMessage;
  double get generationProgress => _generationProgress;
  bool get hasUploadedImage => _uploadedImageFile != null;

  // Upload image to Firebase Storage and create Firestore document
  Future<void> uploadImage(File imageFile) async {
    try {
      _uploadedImageFile = imageFile;
      _uploadedImagePath = imageFile.path;
      _appState = AppState.uploaded;
      _errorMessage = '';
      notifyListeners();

      // Get current user ID
      final userId = _authService.currentUserId;
      if (userId == null) {
        throw Exception('User not authenticated');
      }

      // Generate unique image ID
      _currentImageId = _uuid.v4();

      // Upload original image to Firebase Storage
      _originalImageUrl = await _storageRepository.uploadOriginalImage(
        userId: userId,
        imageId: _currentImageId!,
        imageFile: imageFile,
      );

      // Create Firestore document
      await _firestoreRepository.createPhotoDocument(
        userId: userId,
        imageId: _currentImageId!,
        originalUrl: _originalImageUrl!,
      );
    } catch (e) {
      _errorMessage = 'Failed to upload image: ${e.toString()}';
      _appState = AppState.error;
      notifyListeners();
    }
  }

  // Generate images using Cloud Functions ONLY
  // ALL AI logic is in backend - mobile app just calls the function
  Future<void> generateImages() async {
    if (_originalImageUrl == null || _currentImageId == null) {
      _errorMessage = 'Please upload an image first';
      _appState = AppState.error;
      notifyListeners();
      return;
    }

    _appState = AppState.generating;
    _errorMessage = '';
    _generationProgress = 0.0;
    notifyListeners();

    try {
      // Get current user ID
      final userId = _authService.currentUserId;
      if (userId == null) {
        throw Exception('User not authenticated');
      }

      // Progress simulation while Cloud Function processes
      _generationProgress = 0.1;
      notifyListeners();

      // Call Cloud Function - ALL AI logic happens on backend
      // This is secure - no API keys or AI logic exposed in mobile app
      log('Calling Cloud Function with imageUrl: $_originalImageUrl');
      final result = await _functionsRepository.generateImagesWithTimeout(
        imageUrl: _originalImageUrl!,
        timeout: const Duration(minutes: 10), // Increased for Gemini image generation
      );
      log('Cloud Function response: $result');

      _generationProgress = 0.8;
      notifyListeners();

      // Extract data from Cloud Function response
      log('Extracting data from response...');
      final generatedUrls = result['generatedUrls'] as List<String>;
      final styles = result['stylesUsed'] as List<String>? ?? [];
      log('Generated ${generatedUrls.length} images with styles: $styles');

      // If no images were generated, throw error
      if (generatedUrls.isEmpty) {
        throw Exception('No images generated by Cloud Function');
      }

      // Skip Firestore update for now - URLs are too long
      // TODO: Store only image IDs or use shorter URLs
      print('Skipping Firestore update (URLs too long for Firestore)');

      // Create GeneratedImage objects for UI
      _generatedImages = List.generate(
        generatedUrls.length,
        (index) => GeneratedImage(
          id: _uuid.v4(),
          url: generatedUrls[index],
          style: index < styles.length ? styles[index] : 'Generated Style ${index + 1}',
        ),
      );

      _generationProgress = 1.0;
      notifyListeners();

      await Future.delayed(const Duration(milliseconds: 300));

      _appState = AppState.results;
      notifyListeners();
    } catch (e, stackTrace) {
      log('Error in generateImages: $e');
      log('Stack trace: $stackTrace');
      _errorMessage = 'Failed to generate images: ${e.toString()}';
      _appState = AppState.error;
      _generationProgress = 0.0;
      notifyListeners();
    }
  }

  // Load saved/bookmarked images from Firestore
  Future<void> loadSavedImages() async {
    try {
      final userId = _authService.currentUserId;
      if (userId == null) return;

      final savedData = await _firestoreRepository.getSavedImages(userId: userId);
      
      // Convert to GeneratedImage objects
      _savedImages = savedData.map((data) {
        return GeneratedImage(
          id: data['id'] as String,
          url: data['url'] as String,
          style: data['style'] as String,
          createdAt: data['savedAt'] as DateTime,
        );
      }).toList();
      
      notifyListeners();
    } catch (e) {
      log('Error loading saved images: $e');
    }
  }

  // Save/bookmark image to Firestore
  Future<void> saveImage(GeneratedImage image) async {
    try {
      final userId = _authService.currentUserId;
      log('Attempting to save image. UserId: $userId, ImageId: ${image.id}');
      
      if (userId == null) {
        log('Cannot save: User not authenticated');
        return;
      }

      // Save to Firestore
      log('Saving to Firestore: users/$userId/saved/${image.id}');
      await _firestoreRepository.saveImage(
        userId: userId,
        imageId: image.id,
        imageUrl: image.url,
        style: image.style,
      );
      log('Successfully saved to Firestore');

      // Add to local list if not already there
      if (!_savedImages.any((img) => img.id == image.id)) {
        _savedImages.add(image);
        notifyListeners();
      }
    } catch (e) {
      log('Error saving image: $e');
    }
  }

  // Unsave/unbookmark image from Firestore
  Future<void> unsaveImage(String imageId) async {
    try {
      final userId = _authService.currentUserId;
      if (userId == null) return;

      // Remove from Firestore
      await _firestoreRepository.unsaveImage(
        userId: userId,
        imageId: imageId,
      );

      // Remove from local list
      _savedImages.removeWhere((img) => img.id == imageId);
      notifyListeners();
    } catch (e) {
      log('Error unsaving image: $e');
    }
  }

  // Check if image is saved
  bool isImageSaved(String imageId) {
    return _savedImages.any((img) => img.id == imageId);
  }

  // Reset all
  void reset() {
    _uploadedImageFile = null;
    _uploadedImagePath = null;
    _currentImageId = null;
    _originalImageUrl = null;
    _generatedImages = [];
    _appState = AppState.empty;
    _errorMessage = '';
    _generationProgress = 0.0;
    notifyListeners();
  }

  // Clear generated images only
  void clearGenerated() {
    _generatedImages = [];
    if (_uploadedImageFile != null) {
      _appState = AppState.uploaded;
    } else {
      _appState = AppState.empty;
    }
    notifyListeners();
  }
}
